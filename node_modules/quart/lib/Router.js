const url = require('url');
const http2 = require('http2');
const MapList = require('./MapList');
const WeakList = require('./WeakList');
const SubStream = require('./SubStream');
const SafeError = require('./SafeError');
const MergedList = require('./MergedList');
const {
  HTTP2_HEADER_METHOD,
  HTTP2_HEADER_PATH,
  HTTP2_HEADER_STATUS,
  HTTP2_HEADER_CONTENT_TYPE
} = http2.constants;

class Router {
  constructor() {
    this.middleware = new WeakList();
    this._routeMap = new MapList();
  }

  handlePush(stream, path, headers, options) {
    const push_headers = headers || {};
    push_headers[HTTP2_HEADER_PATH] = path;
    stream.pushStream(push_headers, options, (pushStream) => {
      this.routeStream(pushStream, push_headers);
    });
  }

  handleNotFound(stream) {
    stream.respond({
      'content-type': 'text/plain',
      [HTTP2_HEADER_STATUS]: 404
    });
    stream.end('Not found');
  }

  handleSafeError(stream, error) {
    stream.respond(Object.assign({
      'content-type': 'text/plain',
      [HTTP2_HEADER_STATUS]: error.statusCode
    }, error.headers || {}));
    stream.end(error.message);
  }

  handleError(stream, error) {
    stream.respond({
      'content-type': 'text/plain',
      [HTTP2_HEADER_STATUS]: 500
    });
    stream.end('Internal Server Error');
  }

  handleGenericError(stream, error) {
    if (error instanceof SafeError) {
      this.handleSafeError(stream, error);
    } else {
      this.handleError(stream, error);
    }
  }

  createRouteHandler(handler) {
    if (typeof handler === 'function') return handler;
    else {
      return (stream) => {
        if (typeof handler[stream.method.toLowerCase()] === 'function') handler[stream.method.toLowerCase()](stream);
        else this.handleNotFound(stream);
      };
    }
  }

  handle(route, handler) {
    // Routes are queued one after each other and called in that order
    this._routeMap.push(route, this.createRouteHandler(handler));
  }

  use(handler) {
    this.middleware.push(handler);
  }

  async compose(sub_stream, route) {
    const list = new MergedList();
    // Add middlewares
    list.add(this.middleware);

    if (this._routeMap.has(route)) {
      list.add(this._routeMap.get(route));
    } else {
      list.add([() => this.handleNotFound(sub_stream)]);
    }

    const size = list.size;
    let index = 0;

    const next = async () => {
      if (index >= size) return;
      const func = list.get(index++);
      const result = await func(sub_stream, next);
      // Result of each run is fed back to sub_stream
      return sub_stream._feed(result);
    };

    return await next(index);
  }

  async routeStream(stream, headers) {
    const method = headers[HTTP2_HEADER_METHOD];
    const parsed_url = url.parse(headers[HTTP2_HEADER_PATH]);
    const route = parsed_url.pathname;
    const sub_stream = new SubStream(
      stream,
      (path, headers, options) => this.handlePush(stream, path, headers, options),
      method,
      headers,
      parsed_url.query
    );

    sub_stream.on('error', (error) => this.handleGenericError(sub_stream, error));

    try {
      await this.compose(sub_stream, route);
    } catch (error) {
      this.handleGenericError(sub_stream, error);
    }
  }
}

module.exports = Router;