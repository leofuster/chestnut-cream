const fs = require('fs');
const http2 = require('http2');
const querystring = require('querystring');
const SafeError = require('./SafeError');
const { EventEmitter } = require('events');
const {
  HTTP2_HEADER_PATH,
  HTTP2_HEADER_STATUS,
  HTTP2_HEADER_CONTENT_TYPE,
  HTTP2_HEADER_CONTENT_LENGTH
} = http2.constants;

/**
 * Abstraction over Node.js' http/2 stream
 */
class SubStream extends EventEmitter {
  /**
   * Creates a new sub stream (not an actual stream)
   * @param {Http2Stream} stream
   * @param {function} pushHandler - Called when stream is requesting a push, must return a promise
   * @param {string} method - request method
   * @param {object} headers
   * @param {object} [query] - request query
   */
  constructor(stream, pushHandler, method, headers, query) {
    super();

    this._stream = stream;
    this.headers = headers;
    this.method = method;
    this.query = querystring.parse(query || '') || {};
    this.open = true;
    this._pushHandler = pushHandler;
    this._hasHeadersSent = false;
    this.responseHeaders = {
      [HTTP2_HEADER_STATUS]: 200
    };
    this._stream.on('error', (error) => this.emit('error', error));
  }

  _checkFileStats(stats, headers) {
    /** @todo: Check etag */
    /** @todo: return 304 */
  }

  _feed(data) {
    if (data) {
      // Detect content-type //
      // Readable stream
      if (typeof data === 'string') {
        // String type
        this.setResponseHeaders({
          [HTTP2_HEADER_CONTENT_TYPE]: this.responseHeaders[[HTTP2_HEADER_CONTENT_TYPE]] || "plain/text",
          [HTTP2_HEADER_CONTENT_LENGTH]: data.length
        });
        this.end(data);
      } else if (Buffer.isBuffer(data)) {
        // Buffer type
        this.setResponseHeaders({
          [HTTP2_HEADER_CONTENT_TYPE]: this.responseHeaders[[HTTP2_HEADER_CONTENT_TYPE]] || "application/octet-stream",
          [HTTP2_HEADER_CONTENT_LENGTH]: data.size
        });
        this.end(data);
      } else if ((typeof data === 'object') && (typeof data.pipe === 'function') && (data.readable)) {
        // Piped Stream
        this.setResponseHeaders({
          [HTTP2_HEADER_CONTENT_TYPE]: this.responseHeaders[[HTTP2_HEADER_CONTENT_TYPE]] || "application/octet-stream"
        });
        this.endWithStream(data);
      } else if (typeof data === 'object') {
        const stringified = JSON.stringify(data);
        // JSON/Array stringified
        this.setResponseHeaders({
          [HTTP2_HEADER_CONTENT_TYPE]: this.responseHeaders[[HTTP2_HEADER_CONTENT_TYPE]] || "application/json",
          [HTTP2_HEADER_CONTENT_LENGTH]: stringified.length
        });
        this.end(stringified);
      }
    }
  }

  /**
   * Merge response headers
   * @param {object} headers
   * @returns {object} Response Headers
   */
  setResponseHeaders(headers) {
    for (const key in headers) {
      this.responseHeaders[key] = headers[key];
    }
    return this.responseHeaders;
  }

  /**
   * Set statusCode in headers
   * @param {number} statusCode
   */
  setStatus(statusCode) {
    this.responseHeaders[HTTP2_HEADER_STATUS] = statusCode;
  }

  /**
   * Send response
   * @param {object} [headers] - Optional and additional headers
   */
  respond(headers) {
    if (this._hasHeadersSent) return; /** @todo: Log error for resend of headers */

    // Set bare headers
    if (!this.responseHeaders[[HTTP2_HEADER_CONTENT_TYPE]]) {
      this.responseHeaders[[HTTP2_HEADER_CONTENT_TYPE]] = 'text/plain';
    }

    if (headers) {
      this._stream.respond(this.setResponseHeaders(headers));
    } else {
      this._stream.respond(this.responseHeaders);
    }
    this._hasHeadersSent = true;
  }

  /**
   * Send a file descriptor (fd) as a response
   * @param {number} fd - File descriptor (fd) integer
   * @param {number} [offset] - Offset number of bytes to start reading from fd
   * @param {number} [length] - Total number of bytes to read from fd
   */
  sendFD(fd, offset, length) {
    /** @todo: Add guard for headersSent */
    // Set default content-type
    if (!this.responseHeaders[[HTTP2_HEADER_CONTENT_TYPE]]) {
      this.responseHeaders[[HTTP2_HEADER_CONTENT_TYPE]] = "application/octet-stream";
    }
    this._stream.respondWithFD(fd, this.responseHeaders, {
      offset,
      length
    });
  }

  /**
   * Send a file a response
   * @param {string} path - Path to file
   * @param {number} [offset] - Offset number of bytes to start reading from file
   * @param {number} [length] - Total number of bytes to read from file
   */
  sendFile(pathToFile, offset, length) {
    /** @todo: Add guard for headersSent */
    /** @todo: Content-type detection from file extension */
    if (!fs.existsSync(pathToFile)) return this.emit('error', new SafeError("File Not Found", 404));
    
    this.responseHeaders[[HTTP2_HEADER_CONTENT_TYPE]] = "application/octet-stream";
    this._stream.respondWithFile(pathToFile, this.responseHeaders, {
      offset,
      length,
      statCheck: (stats, headers) => this._checkFileStats(stats, headers)
    });
  }

  /**
   * Pushes a handle to Client (see https://nodejs.org/api/http2.html#http2_http2stream_pushstream_headers_options_callback)
   * @param {string} path - URI to route to
   * @param {object} headers
   * @param {object} [options] - Optional parameters passed to http2stream.pushStream
   */
  async push(path, headers, options) {
    if (!this._stream.pushAllowed) return false;
    return await this._pushHandler(path, headers || {}, options);
  }

  /**
   * Write a piece of data (chunk) to the stream
   * @param {string|Buffer} chunk
   */
  write(chunk) {
    this._stream.write(chunk);
  }

  /**
   * End stream with optional response
   * Use return statements in async functions instead
   * @param {string|Buffer} [buffer] - Optional buffer
   */
  end(buffer) {
    if (!this._hasHeadersSent) this.respond();

    this.open = false;
    this._stream.end(buffer);
  }

  /**
   * Ends response stream after piping a given stream to it
   * @param {Duplex|Readable} stream
   */
  endWithStream(stream) {
    if (!this._hasHeadersSent) this.respond();

    this.open = false;
    stream.pipe(this._stream);
  }
}

module.exports = SubStream;