# Writing a **Quart** Http/2 server
The first requirement for writing a valid HTTP/2 server would be to obtain a valid or self-signed set of SSL certificates [(Let's Encrypt is a great solution)](https://letsencrypt.org/) as most major browsers only support secure HTTP/2. You can pass the value of the certificate and key pair to **Quart** when creating a new instance:
```javascript
const Quart = require('Quart');
const app = new Quart({
  cert: "", // SSL Cert
  key: "" // SSL Key
});

app.listen(8080);
```
Once we have our certificates setup we can add a route using the `on` method:
```javascript
app.handle('/', async (stream) => "Hello World!");
```
Our route is an async function that returns a string `Hello World` back to the client when the root route is requested. In **Quart**, request and response objects are represented as a SubStream with an underlying HTTP2Stream and responses are determined by the return statement of a handle.

## JSON endpoint
JSON endpoints can be created with ease, using an async function we can wait for the response from a database/external request and return it to the user, **Quart** will automatically set the `content-type`, `content-length` headers and convert our object to JSON:
```javascript
const Quart = require('Quart');
const Users = require('./db/Users'); // Example
const app = new Quart({/* options */});

app.handle('/get_users', async (stream) => {
  if (!stream.query.group) throw new Error("No User group provided in Query");
  const users = await Users.get(stream.query.group);

  return users;
});

app.listen(8080);
```

----

### Multiplexing & Push
Multiplexing is done by default in **Quart** and therefore requires no effort, additionally any route can be pushed back to the client once the push feature lands in *v0.5.0*.

HTTP/2 servers written with **Quart** should be very familiar to developers who have been developing with other Node.js based HTTP frameworks, much of the HTTP/2 complexity is either abstracted by Node or **Quart**.